# The Network Layer

## 4.1 Introduction

### 4.1.1 Forwarding and Routing

- Forwarding: เมื่อแพ็คเกตที่ถูกส่งมาจากโฮสต์ทางขาเข้า (input link) แล้ว กระบวนการที่ทำการย้ายแพ็คเกตดังกล่าวนี้ไปยังขาออก (output link) ที่เหมาะสมเรียกว่าการ forwarding
- Routing: เป็นกระบวนการที่ใช้ในการค้นหาเส้นทางที่เหมาะสมให้กับแพ็คเกต เพื่อให้การส่งแพ็คเกตเป็นไปอย่างมีประสิทธิภาพมากที่สุด โดยจะมีการใช้อัลกอริธึมที่เรียกว่า Routing Algorithms ในการหาเส้นทาง

Forwarding Table (a.k.a. Routing Table): เป็นองค์ประกอบของเราท์เตอร์ที่ใช้เก็บข้อมูลที่ได้มาจากการตรวจสอบส่วนหัวของแพ็คเกตกับอินเตอร์เฟสขาออกของเราท์เตอร์ โดยค่าที่อยู่ใน Forwarding table อาจถูกกำหนดจากผู้ใช้งาน หรือจากการใช้ Routing Algorithms ช่วยก็ได้

โดยลักษณะของการ forwarding จะถูกใช้อีกครั้งในกระบวนการ Packet switch ซึ่งอยู่ใน Link-layer โดยใน Link-layer (layer 2) นั้น กระบวนการตัดสินใจว่าจะส่งแพ็คเกตไปยังอินเตอร์เฟสใดจะขึ้นอยู่กับค่าที่อยู่ในฟิลด์ของเฟรมของ Link-layer ในขณะที่การ forwarding ใน Network layer นั้นจะขึ้นอยู่กับที่อยู่ในฟิลด์ของ Network layer

เราท์เตอร์เป็นอุปกรณ์ที่อยู่ใน Network layer (layer 3) แต่ก็ยังต้องมีการประยุกต์ใช้คุณสมบัติของ Link-layer (layer 2) ด้วย ในทางการตลาดนั้นจะเรียกเราท์เตอร์ที่มีอินเตอร์เฟส Ethernet ว่าเป็น "สวิตซ์ในเลเยอร์ที่ 3"

### 4.1.2 Network Service Models

เมื่อมีการส่งข้อมูลโดยใช้โปรโตคอลที่ต้องอาศัยความเชื่อถือจากชั้น Transport layer ลงมายังชั้นของ network layer คุณสมบัติต่างๆ ที่ Network layer จะต้องมีเพื่อสนับสนุนการทำงานของ Transport layer นั้นจะเรียกว่า Network service model

ตัวอย่างของ Network service model เช่น

- Guaranteed delivery: จะต้องการันตีว่าแพ็คเกตที่ถูกส่งนั้นจะต้องถึงโฮสต์ปลายทาง
- Guaranteed delivery with bounded delay: นอกจากจะมีการการันตีว่าแพ็คเกตนั้นจะถูกส่งถึงโฮส์เป้าหมายแล้ว ยังมีการกำหนดขอบเขตของดีเลย์ด้วย

นอกจากในเรื่องของความน่าเชื่อถือในการส่งแพ็คเกตแล้ว ยังมี network service model ที่จัดการเกี่ยวกับการไหลของแพ็คเกตด้วย

- In-order packet delivery: การันตีว่าแพ็คเกตที่ถูกส่งนั้นจะถึงผู้รับด้วยลำดับรูปแบบเดียวกันกับตอนที่ผู้ส่งส่งออกมา
- Guaranteed minimal bandwidth: การันตีแบนด์วิธที่น้อยที่สุดที่จะสามารถใช้ในการส่งข้อมูลได้ โดยที่ข้อมูลจะต้องถึงผู้รับอย่างสมบูรณ์
- Guaranteed maximum jitter: การันตีในเรื่องของเวลาที่จะต้องเท่ากันหรือไม่มากกว่าค่าๆ หนึ่ง
- Security services: ในกรณีที่มีการใช้เข้ารหัสด้วยคีย์ network layer ฝั่งผู้รับจะต้องสามารถเข้ารหัส Payloads ของ Datagram ด้วยคีย์นั้นได้เช่นเดียวกันฝั่งผู้ส่งที่จะต้องรับหน้าที่ในการเข้ารหัส payloads และยังต้องสามารถให้บริการในเรื่องของความสมบูรณ์ของข้อมูล และการระบุตัวตนด้วย

ในเครือข่ายอินเทอร์เน็ตใน network layer จะมีการให้บริการที่เรียกว่า *Best-effort service* ซึ่งหมายความง่ายๆ ว่า *No service at all* หรือไม่ให้บริการใดๆ เลย เพื่อทำให้เครือข่ายนี้ใช้งานได้ง่ายที่สุด

เครือข่ายอินเทอร์เน็ตถือเป็นสถาปัตยกรรมทางเครือข่ายแบบหนึ่ง (Network architecture) และยังมีสถาปัตยกรรมเครือข่ายอื่นๆ อีกด้วย เช่น ATM (Asynchronous Transfer Mode) โดยตัว ATM จะมีการใช้ service model สำคัญๆ สองบริการ ดังนี้

- Constant bit rate (CBR): มีการการันตีค่าที่แน่นอนของแบนด์วิธ, มีการการันตีว่าข้อมูลจะไม่สูญหาย, มีการการันตีว่าจะถูกส่งตามลำดับที่ถูกต้อง, มีการจัดการเวลาในการส่ง และมีการป้องกันการเกิดความคับคั่งระหว่างการส่งข้อมูล
- Available bit rate (ABR): มีการการันตีค่าแบนด์วิธที่น้อยที่สุด, การการันตีในเรื่องลำดับของข้อมูล และมีตัวตรวจสอบความคับคั่ง (นอกเหนือจากนี้คือไม่มีการให้บริการ)

## 4.2 Virtual Circuit and Datagram Networks

ในเรื่องของ Transport layer ได้มีการกล่าวถึงตัวเลือกสำหรับแอพพลิเคชัน หากต้องหากใช้ลักษณะการเชื่อมต่อที่น่าจะเชื่อถือก็จะใช้ TCP ที่มี cnnection-oriented แต่ถ้าต้องการความสะดวกรวดเร็วก็ใช้ UDP ที่เป็น connectionless ซึ่งใน Network layer นี้ก็มีตัวเลือกเช่นเดียวกับใน Transport layer

แม้ว่าการมี Connection กับ Connectionless ของ Transport layer กับ Network layer จะค่อนข้างคล้ายกัน แต่ก็มีจุดที่แตกต่างกันคือ

- Network layer เป็นกระบวนการที่ให้ความสนใจในการติดต่อระหว่าง host-to-host ในขณะที่ Transport layer มุ่งไปที่ process-to-process
- แม้ว่าในเครือข่ายปัจจุบันจะมีการใช้ทั้ง connection และ connectionless แต่ก็ยังคงมีบางเครือข่ายที่ใช้เพียงอย่างใดอย่างหนึ่ง เราจะเรียกเครือข่ายที่มีการใช้ connection เพียงอย่างเดียวว่า **Virtual-circuit (VC) networks** ในขณะเดียวกันเราเรียกเครือข่ายที่มีการใช้ connectionless เพียงอย่างเดียวว่า **Datagram networks**

## 4.2.1 Virtual-Circuit Networks

กระบวนการทำงานของ VC networks นั้นมีองค์ประกอบสำคัญ 3 อย่าง ดังนี้

1. Path: กลุ่มของลิงก์และเราท์เตอร์ที่เชื่อมหากันระหว่างโฮสต์ต้นทางกับโฮสต์ปลายทาง
2. VC numbers: เป็นตัวเลข VC ที่กำหนดไว้ในแต่ละลิงก์
3. Forwarding table: ตารางที่ใช้ในการควบคุมการส่งในแต่ละเราท์เตอร์

โดยจะแบ่งกระบวนการทำงานออกเป็น 3 ขั้นตอนดังนี้

1. VC setup: Transport layer มีการส่งสัญญาณมาให้กับ Network layer  โดยจะมีการระบุที่อยู่ของผู้รับไว้ และรอการตอบรับจาก Network layerNetwork layer ทำการหาเส้นทางที่เหมาะสมจากต้นทางไปยังปลายทาง เมื่อได้เส้นทางแล้ว Network layer ทำการตรวจสอบ VC numbers ของแต่ละลิงก์ แล้วทำการเพิ่มใส่ใน Forwarding table ของแต่ละเราท์เตอร์ในเส้นทาง
2. Data Transfer: หลังจากมีการตั้งค่า VC เสร็จแล้ว ก็จะส่งสัญญาณให้มีการส่งข้อมูลได้ โดยก่อนที่แพ็คเกตจะออกจากเราท์เตอร์ ก็จะมีการเปลี่ยนส่วนหัวของแพ็คเกตเป็น VC numbers ตัวถัดไป และเมื่อแพ็คเกตเข้าไปยังขาเข้าก็จะมีการอ่านค่าจากส่วนนี้เช่นกัน
3. VC teardown: หากมีการจะปิด VC ก็จะมีการสั่งให้เราท์เตอร์ในเส้นทางทำการอัพเดต forwarding table

ภายใน Forwarding table จะมีการเก็บอินเตอร์เฟสขาเข้า, VC number ที่จะรับ, อินเตอร์เฟสขาออก และ VC number ที่จะส่งออกไปด้วย และสัญญาณที่ใช้ในการควบคุม VC นั้นจะเรียกว่า signaling messages อยู่ใน signaling protocols 

## 4.7 Broadcast and Multicast Routing

- Broadcast Routing: การส่งแพ็คเกตจากโหนดที่เป็นผู้ส่ง (source node) หนึ่งโหนดไปยังโหนดผู้รับ (destination node) หลายๆ โหนด
- Multicast Routing: การส่งแพ็คเกตจากโหนดที่เป็นผู้ส่ง (source node) หนึ่งโหนดไปยังโหนดผู้รับ (destination node) หลายๆ โหนด **โดยที่สามารถข้ามซับเน็ตได้**

### 4.7.1 Broadcast Routing Algorithm

- อัลกอริธึมแบบ N-way-unicast อธิบายง่ายๆ คือ เรามีโหนดผู้ส่งหนึ่งโหนดและจะทำการส่งไปยังโหนดผู้รับจำนวน N โหนด ในอัลกอริธึมนี้โหนดผู้ส่งจะทำการคัดลอกแพ็คเกตที่จะส่งไว้จำนวน N แพ็คเกต และทำการส่งแบบ Unicast Routing ไปยังแต่ละโหนดผู้รับ
    - ข้อดี
        - ง่าย
    - ข้อเสีย
        - ไม่มีประสิทธิภาพ เพราะว่า ผู้ส่งจะต้องทำการส่งหลายรอบ
        - ผู้ส่งจำเป็นต้องรู้รายละเอียดของผู้รับทั้งหมด ทำให้ต้องมีการเพิ่มโปรโตคอลเพิ่มเติม
        - ปัญหาการ Flooding: กรณีการ Flooding จะเกิดขึ้นจากการแก้ปัญหาผู้ส่งคนเดียวส่งให้ผู้ใช้หลายคนโดยใช้วิธีให้โหนดที่ใกล้กันทำการส่งหาโหนดที่ใกล้กันเอง ในกรณีนี้หากมีโทโปโลยีที่มีลักษณะพิเศษ อาจเกิดการ Flooding แบบไม่มีที่ิสิ้นสุดซึ่งเรียกว่า Broadcast Storm ได้
    - ฟีเจอร์เพิ่มเติม
        - การแก้ไขปัญหา Source-duplication แก้ได้โดยการใช้การกระจายเพียงแค่โหนดข้างเคียงและส่งต่อไปเรื่อยๆ ( แต่จะเกิดปัญหาแบบ Broadcast srom ได้ )
        - การแก้ไขปัญหา Flooding ทำได้สองวิธีคือ
            1. การใข้วิธี Sequence-number-controlled flooding 
            2. การใช้วิธี Reverse Path Forwarding (RPF)
        - การแก้ปัญหาแพ็คเกตซ้ำทำได้โดยการใช้วิธี Spanning-Tree Broadcast

### 4.7.2 Multicast
