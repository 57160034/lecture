# The Network Layer

## 4.1 Introduction

### 4.1.1 Forwarding and Routing

- Forwarding: เมื่อแพ็คเกตที่ถูกส่งมาจากโฮสต์ทางขาเข้า (input link) แล้ว กระบวนการที่ทำการย้ายแพ็คเกตดังกล่าวนี้ไปยังขาออก (output link) ที่เหมาะสมเรียกว่าการ forwarding
- Routing: เป็นกระบวนการที่ใช้ในการค้นหาเส้นทางที่เหมาะสมให้กับแพ็คเกต เพื่อให้การส่งแพ็คเกตเป็นไปอย่างมีประสิทธิภาพมากที่สุด โดยจะมีการใช้อัลกอริธึมที่เรียกว่า Routing Algorithms ในการหาเส้นทาง

Forwarding Table (a.k.a. Routing Table): เป็นองค์ประกอบของเราท์เตอร์ที่ใช้เก็บข้อมูลที่ได้มาจากการตรวจสอบส่วนหัวของแพ็คเกตกับอินเตอร์เฟสขาออกของเราท์เตอร์ โดยค่าที่อยู่ใน Forwarding Table อาจถูกกำหนดจากผู้ใช้งาน หรือจากการใช้ Routing Algorithms ช่วยก็ได้

โดยลักษณะของการ forwarding จะถูกใช้อีกครั้งในกระบวนการ packet switch ซึ่งอยู่ใน link-layer โดยใน link-layer (layer 2) นั้น กระบวนการตัดสินใจว่าจะส่งแพ็คเกตไปยังอินเตอร์เฟสใดจะขึ้นอยู่กับค่าที่อยู่ในฟิลด์ของเฟรมของ link-layer ในขณะที่การ forwarding ใน network layer นั้นจะขึ้นอยู่กับที่อยู่ในฟิลด์ของ network layer

เราท์เตอร์เป็นอุปกรณ์ที่อยู่ใน network layer (layer 3) แต่ก็ยังต้องมีการประยุกต์ใช้คุณสมบัติของ link-layer (layer 2) ด้วย ในทางการตลาดนั้นจะเรียกเราท์เตอร์ที่มีอินเตอร์เฟส Ethernet ว่าเป็น "สวิตซ์ในเลเยอร์ที่ 3"

### 4.1.2 Network Service Models

เมื่อมีการส่งข้อมูลโดยใช้โปรโตคอลที่ต้องอาศัยความเชื่อถือจากชั้น transport layer ลงมายังชั้นของ network layer คุณสมบัติต่างๆ ที่ network layer จะต้องมีเพื่อสนับสนุนการทำงานของ transport layer นั้นจะเรียกว่า network service model

ตัวอย่างของ network service model เช่น

- Guaranteed delivery: จะต้องการันตีว่าแพ็คเกตที่ถูกส่งนั้นจะต้องถึงโฮสต์ปลายทาง
- Guaranteed delivery with bounded delay: นอกจากจะมีการการันตีว่าแพ็คเกตนั้นจะถูกส่งถึงโฮส์เป้าหมายแล้ว ยังมีการกำหนดขอบเขตของดีเลย์ด้วย

นอกจากในเรื่องของความน่าเชื่อถือในการส่งแพ็คเกตแล้ว ยังมี network service model ที่จัดการเกี่ยวกับการไหลของแพ็คเกตด้วย

- In-order packet delivery: การันตีว่าแพ็คเกตที่ถูกส่งนั้นจะถึงผู้รับด้วยลำดับรูปแบบเดียวกันกับตอนที่ผู้ส่งส่งออกมา
- Guaranteed minimal bandwidth: การันตีแบนด์วิธที่น้อยที่สุดที่จะสามารถใช้ในการส่งข้อมูลได้ โดยที่ข้อมูลจะต้องถึงผู้รับอย่างสมบูรณ์
- Guaranteed maximum jitter: การันตีในเรื่องของเวลาที่จะต้องเท่ากันหรือไม่มากกว่าค่าๆ หนึ่ง
- Security services: ในกรณีที่มีการใช้เข้ารหัสด้วยคีย์ network layer ฝั่งผู้รับจะต้องสามารถเข้ารหัส payloads ของ datagram ด้วยคีย์นั้นได้เช่นเดียวกันฝั่งผู้ส่งที่จะต้องรับหน้าที่ในการเข้ารหัส payloads และยังต้องสามารถให้บริการในเรื่องของความสมบูรณ์ของข้อมูล และการระบุตัวตนด้วย

ในเครือข่ายอินเทอร์เน็ตใน network layer จะมีการให้บริการที่เรียกว่า *best-effort service* ซึ่งหมายความง่ายๆ ว่า *no service at all* หรือไม่ให้บริการใดๆ เลย เพื่อทำให้เครือข่ายนี้ใช้งานได้ง่ายที่สุด

เครือข่ายอินเทอร์เน็ตถือเป็นสถาปัตยกรรมทางเครือข่ายแบบหนึ่ง (Network architecture) และยังมีสถาปัตยกรรมเครือข่ายอื่นๆ อีกด้วย เช่น ATM (Asynchronous Transfer Mode) โดยตัว ATM จะมีการใช้ service model สำคัญๆ สองบริการ ดังนี้

- Constant bit rate (CBR): มีการการันตีค่าที่แน่นอนของแบนด์วิธ, มีการการันตีว่าข้อมูลจะไม่สูญหาย, มีการการันตีว่าจะถูกส่งตามลำดับที่ถูกต้อง, มีการจัดการเวลาในการส่ง และมีการป้องกันการเกิดความคับคั่งระหว่างการส่งข้อมูล
- Available bit rate (ABR): มีการการันตีค่าแบนด์วิธที่น้อยที่สุด, การการันตีในเรื่องลำดับของข้อมูล และมีตัวตรวจสอบความคับคั่ง (นอกเหนือจากนี้คือไม่มีการให้บริการ)

## 4.7 Broadcast and Multicast Routing

- Broadcast Routing: การส่งแพ็คเกตจากโหนดที่เป็นผู้ส่ง (source node) หนึ่งโหนดไปยังโหนดผู้รับ (destination node) หลายๆ โหนด
- Multicast Routing: การส่งแพ็คเกตจากโหนดที่เป็นผู้ส่ง (source node) หนึ่งโหนดไปยังโหนดผู้รับ (destination node) หลายๆ โหนด **โดยที่สามารถข้ามซับเน็ตได้**

### 4.7.1 Broadcast Routing Algorithm

- อัลกอริธึมแบบ N-way-unicast อธิบายง่ายๆ คือ เรามีโหนดผู้ส่งหนึ่งโหนดและจะทำการส่งไปยังโหนดผู้รับจำนวน N โหนด ในอัลกอริธึมนี้โหนดผู้ส่งจะทำการคัดลอกแพ็คเกตที่จะส่งไว้จำนวน N แพ็คเกต และทำการส่งแบบ Unicast Routing ไปยังแต่ละโหนดผู้รับ
    - ข้อดี
        - ง่าย
    - ข้อเสีย
        - ไม่มีประสิทธิภาพ เพราะว่า ผู้ส่งจะต้องทำการส่งหลายรอบ
        - ผู้ส่งจำเป็นต้องรู้รายละเอียดของผู้รับทั้งหมด ทำให้ต้องมีการเพิ่มโปรโตคอลเพิ่มเติม
        - ปัญหาการ Flooding: กรณีการ Flooding จะเกิดขึ้นจากการแก้ปัญหาผู้ส่งคนเดียวส่งให้ผู้ใช้หลายคนโดยใช้วิธีให้โหนดที่ใกล้กันทำการส่งหาโหนดที่ใกล้กันเอง ในกรณีนี้หากมีโทโปโลยีที่มีลักษณะพิเศษ อาจเกิดการ Flooding แบบไม่มีที่ิสิ้นสุดซึ่งเรียกว่า Broadcast Storm ได้
    - ฟีเจอร์เพิ่มเติม
        - การแก้ไขปัญหา Source-duplication แก้ได้โดยการใช้การกระจายเพียงแค่โหนดข้างเคียงและส่งต่อไปเรื่อยๆ ( แต่จะเกิดปัญหาแบบ Boardcast Strom ได้ )
        - การแก้ไขปัญหา Flooding ทำได้สองวิธีคือ
            1. การใข้วิธี Sequence-number-controlled flooding 
            2. การใช้วิธี Reverse Path Forwarding (RPF)
        - การแก้ปัญหาแพ็คเกตซ้ำทำได้โดยการใช้วิธี Sapnning-Tree Broadcast

### 4.7.2 Multicast
