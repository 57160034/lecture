# IPv6

## IPv6 Address Notation

IPv6 มีขนาด 128-bit ซึ่งถูกแบ่งออกเป็นแปดส่วน ส่วนละ 16-bit (hextets คือคำที่ไม่เป็นทางการในการใช้เรียกส่วน 16-bit นี้ โดยต่อไปจะเรียกว่าเซ็กเมนต์) โดยค่าของ IPv6 นั้นเป็นค่าที่อยู่ในลักษณะของเลขฐานสิบหก (hexadecimal) ที่มีค่าอยู่ระหว่าง `0000` ถึง `FFFF` (non-case sensitive — ตัวใหญ่, ตัวเล็กถือว่าเป็นตัวเดียวกัน) และแต่ละเซ็กเมนต์จะถูกแบ่งด้วยเครื่องหมาย `:` (colon) จากลักษณะของ IPv6 ขนาด **128-bit** นี้ทำให้เราสามารถนำมาใช้ในการ addressing ได้กว่า 3.4*(10^38)  โฮสต์

## Rules of IPv6

กฎของ IPv6 เป็นกฎที่ทำให้เราสามารถลดขนาดของ IPv6 ลงได้ในบางกรณี ซึ่งแต่ละกฎมีรายละเอียดดังนี้

1. *Leading 0's*: หากแต่ละเซ็กเมนต์ซึ่งมีขนาด 16-bit นั้นถูกนำหน้าด้วยเลข 0 การเขียนหรืออธิบาย IPv6 ชุดนั้นสามารถลบเลข 0 ตัวข้างหน้าออกไปได้ เช่น `3ffe:0404:0001:1000:0000:0000:0ef0:bc00` เมื่อเราใช้กฎในข้อที่หนึ่งแล้ว จะสามารถเขียน IPv6 ชุดนี้ได้เป็น `3ffe:404:1:1000:0:0:ef0:bc00`

2. *Double Colons*: หากมีกรณีที่ชุดของ IPv6 มีเซ็กเมนต์ที่มีค่า 0 อยู่ติดกัน เราจะสามารถเขียนชุดของ IPv6 ในรูปแบบย่อได้โดยแทนค่าของ 0 ด้วย :: ยกตัวอย่างเช่น `ff02:0000:0000:0000:0000:0000:0000:0500` จะสามารถเขียนใหม่ได้เป็น `ff:02::500` หรือในกรณีที่เซ็กเมนต์ของ 0 ไม่ได้อยู่ติดกันก็สามารถใช้กฎนี้ได้ ยกตัวอย่างเช่น `2001:0d02:0000:0000:0014:0000:0000:0095` จะสามารถเขียนใหม่ได้เป็น `2001:d02::14:0:0:95` หรือ `2001:d02:0:0:14::95` ก็ได้ โดยในกรณีนี้ชุดของ IPv6 นั้นจะไม่ ควรมีค่าเป็น `2001:d02::14::95` เนื่องจากจะเกิดความกำกวม ซึ่งอาจสามารถเป็นได้ทั้ง `2001:0d02:0000:0000:0014:0000:0000:0095` หรือ `2001:0d02:0000:0000:0000:0014:0000:0095` หรือค่าอื่นๆ ได้

## Network Prefixes

ใน IPv4 นั้นเรามักจะคุ้นเคยกับการใช้ค่าของเลขฐานสิบ เช่น 255.255.255.0 หรือจำนวนบิตที่นับได้เช่น /24 ซึ่งใน IPv6 Prefixes นั้นจะถูกระบุให้ใช้การนับจำนวนบิต (bitcount — prefix length) เสมอ ซึ่งจะทำให้เรา สามารถเขียนชุดของ IPv6 Prefixes ได้เป็น `3ffe:1944:100:a::/64`

## IPv6 Address Types

ในการ Addressing ของ IPv6 นั้นสามารถจำแนกได้ตามประเภทและขอบเขต (scope) โดยเมื่อเราจำแนกโดยใช้ประเภทแล้ว จะได้ดังนี้

- Unicast address: เป็นการส่งข้อมูลจากผู้ส่งรายเดียวไปยังผู้รับรายเดียวบนเครือข่าย
- Multicast address: เป็นการส่งข้อมูลจากผู้ส่งรายเดียวไปยังผู้รับหลายราย
- Anycast address: เป็นการส่งข้อมูลจากผู้ส่งรายเดียวไปยังผู้รับหลายรายซึ่งอยู่ใกล้ที่สุดอ้างอิงจากระยะทางของการ routing
- *IPv6 ไม่มี broadcast address*

โดย Unicast และ Anycast ใน IPv6 นั้นมีขอบเขตดังนี้ (Multicast ถูกขอบเขตไว้แล้วในโครงสร้าง)

- Link-local: เป็นขอบเขตของโหนดที่อยู่ในซับเนตเดียวกันหรือเป็น local link 
- Site-local: เป็นขอบเขตที่ใช้ในเครือข่ายส่วนตัว เปรียบได้กับ Private IPv4 address
- Global: เป็นขอบเขตที่ที่สามารถเข้าถึงได้จากอินเตอร์เน็ต เปรียบได้กับ Public IPv4 address

ซึ่งเมื่อเราอ้างอิงการ addressing จากทั้งประเภทและขอบเขตแล้ว จะสามารถกำหนดคุณลักษณะของแต่ละรูปแบบของชุดของ IPv6 ได้ดังนี้

1. *Global Unicast Addressing*: มีรูปแบบการทำงานคล้ายกับ Public IPv4 address โดยจะต้องมีคุณลักษณะคือสามารถถูก route ได้จากทั้งเครือข่ายภายในและจากอินเทอร์เน็ต (Routable) และมีความเฉพาะตัว (Unique) โดย IANA ได้ทำการจอง 3 บิตแรกไว้คือ `001` สำหรับใช้งานเป็น Global unicast address โดยเฉพาะ นั่นหมายความว่า Global unicast address ทุกตัว ณ ตอนนี้จะมี address อยู่ในช่วงของ `2000::/3` จนถึง `3FFF::/3` (โดยบิตที่ 4 จะเป็นค่า 0 หรือ 1 ก็ได้) สำหรับการแบ่งซับเนตนั้น เราอาจจะนึกถึงภาพแห่งความยากลำบากในการแบ่งใน IPv4 แต่สำหรับ IPv6 นั้นง่ายกว่านั้นมาก โดยในชุดของ IPv6 จะถูกแบ่งออกเป็น Global Routing Prefix ซึ่งเปรียบได้กับ Network portion และ Interface ID ซึ่งเปรียบได้กับ Host portion โดย Interface ID จะมีขนาด 64-bit เท่ากับ 18,446,744,073,709,551,616 (18 quintillion) อุปกรณ์ต่อซับเนตซึ่งเยอะมากเมื่อเทียบกับ IPv4  โดยในส่วนของ Global Routing Prefix ที่เหลืออยู่ 64-bit นั้นจะถูกแบ่งออกเป็น 16-bit เพื่อใช้เป็น Subnet ID (ได้ 65,536 ซับเนต) โดยทั้งหมดนี้จะสามารถเข้าใจโครงสร้างของ Global unicast address ได้จากกฎ 3-1-4 คือ Global Routing Prefix 3 ส่วน (16*3 = 48-bit), Subnet ID 1 ส่วน (16*1 = 16-bit) และ Interface ID 4 ส่วน (16*4 = 64-bit) เมื่อเราลองมองลึกเข้าไปในส่วนของ Global Routing Prefix ขนาด 64-bit นั้น IANA ได้จัดสรร address ขนาด 23-bit ให้กับ RIR ซึ่งเป็นกลุ่มขององค์กรที่คอยจัดสรรทรัพยากรอินเทอร์เน็ตให้ในแต่ละภูมิภาคของโลก และ ISP Prefix จะเป็น 9-bit ต่อมาคือ /32 และอีก 16-bit ที่เหลือจะเป็นในส่วนของ Site Prefix คือจนถึง /48 และอีกต่อมาอีก 8-bit อาจจะใช้เป็น Home Site Prefix (ซึ่งแน่นอนว่ามันเข้าไปซ้อนทับกับ 16-bit ของ Subnet ID ทำให้ Subnet ID เหลือเพียง 8-bit) โดยสำหรับการแบ่งซับเนต (Subnetting IPv6) นั้นง่ายมาก ในกรณีที่เรามี Subnet ID ขนาด 16-bit (ตามกฎ 3-1-4)  เราจะสามารถแบ่งซับเนตได้โดยการเพิ่มค่าทีละ 1 ในรูปแบบของเลขฐานสิบหก เช่น `2340:1111:AAAA::/48` จะแบ่งได้เป็น `2340:1111:AAAA:0000::/64`, `2340:1111:AAAA:0001::/64`, `2340:1111:AAAA:0002::/64` และ `2340:1111:AAAA:000A::/64` ซึ่งเราก็จะสามารถใช้กฎ **Leading 0's** ต่อไปอีกได้ และเรายังสามารถขยายขนาดของ Subnet ID โดยใช้พื้นที่ของ Interface ID ได้ ซึ่งจะทำให้เรามีซับเนตได้มากยิ่งขึ้น สำหรับเรื่องที่กล่าวมาทั้งหมดในข้างต้นจะเป็นรูปแบบของ Static Global Unicast Addresses ซึ่งเป็นแบบ Manual และจะมีอีกวิธีหนึ่งที่ในแบบ Manual เหมือนกันคือ *EUI-64 (64-bit Extended Unique Identifier)* โดย EUI-64 จะใช้ Ethernet MAC Address จำนวน 48-bit เพื่อสร้าง Interface ID ขนาด 64-bit โดยอัตโนมัติ จาก Ethernet MAC Address จำนวน 48-bit นั้นเราจะแบ่งออกเป็นสองส่วนคือส่วนของ OUI 24-bit แรก และ Device Identifier ซึ่งก็คือ 24-bit หลัง และจะทำการเพิ่มค่า `FFFE` ลงไประหว่าง OUI กับ Device Identifier และในขั้นตอนสุดท้ายจะทำการกลับบิตที่ 7 ซึ่งเป็น Universal/Local Bit ซึ่งเมื่อทำการแปลงค่าทั้งหมดกลับเป็น Hexadecimal Notation แล้วก็จะได้ Interface ID ที่มาจากการ EUI-64 ต่อมาเราจะมาพูดถึงการคอนฟิก Global unicast address แบบ Dynamic กันบ้าง ซึ่งการคอนฟิกแบบนี้จะมีสองวิธีคือการใช้ *Stateless Address Autoconfiguration (SLAAC)* และการใช้ DHCPv6 โดยในรูปแบบแรก Stateless Address Autoconfiguration จะใช้การส่งข้อความสองประเภทคือ Router Solicitation และ Router Advertisement (เป็นส่วนหนึ่งของ ICMPv6 Neighbor Discovery Protocol) โดยเราท์เตอร์จะทำหน้าที่ส่ง Router Advertisement และรับ Router Solicitation จากโฮสต์ (เราท์เตอร์ของ Cisco ถูกกำหนดค่าเริ่มต้นสำหรับการรับและส่งเป็น 200s) หน้าที่ของ Router Advertisement คือมันจะทำการคุยกับโฮสต์ว่าจะรับชุดของ IPv6 ได้อย่างไร โดยเราท์เตอร์ที่จะทำการส่ง Router Advertisement นั้นจะต้องได้รับการคอนฟิกก่อน (ขั้นตอนการคอนฟิกดูได้จากท้ายบทความ) Router Advertisement ประกอบด้วยข้อมูลสามส่วน คือ Prefix, Prefix-length และ Default Gateway หรือข้อมูลที่โฮสต์ต้องการในกรณีที่เราท์เตอร์ได้รับข้อความ Router Solicitation ที่ร้องขอข้อมูลแบบเฉพาะเจาะจงมา เช่น หากโฮสต์ต้องการข้อมูลของ DNS Address ข้อมูลภายใน Router Advertisement อาจบอกให้โฮสต์นั้นไปถามที่ DHCPv6 Server ต่อเพราะมันไม่มีข้อมูลในส่วนนี้ Prefix นั้นจะอยู่ในรูปของ Global Routing Prefix กับ Subnet ID เช่น `2001:DB8:AAAA:1::`, Prefix Length นั้นจะเป็น Subnet Mask เช่น /64 ซึ่งจากขั้นตอนนี้โฮสต์ก็สามารถสร้างชุดของ IPv6 ได้เลยจากการใช้ EUI-64 และสุดท้ายคือ Default Gateway คือ FF80::1 ซึ่งเป็น Link-Local Address สำหรับในระบบปฏิบัติการ Windows XP และ Windows Server 2003 จะยังคงใช้ EUI-64 อยู่ แต่ถ้าเป็น Windows Vista หรือรุ่นใหม่กว่านี้ฝั่งโฮสต์จะทำการสุ่มค่า 64-bit Interface ID เอง เนื่องจากเกิดความเป็นไปได้ที่ว่า หากยังมีการใช้ EUI-64 อยู่นั้นจะทำให้ผู้ประสงค์ร้ายสามารถทำการ traceback ไปยังโฮสต์นั้นๆ ได้จาก MAC Address ในกรณีที่เราท์เตอร์ได้ใช้ Router Advertisement ตอบกลับไปยังโฮสต์ว่าไม่มีข้อมูลที่โฮสต์ต้องการ ก็จะเกิดขั้นตอนการแลกเปลี่ยนข้อความคล้ายๆ กันระหว่างโฮสต์กับเซิร์ฟเวอร์ตัวอื่น เช่น DHCPv6 Server ต่อไป นอกจากรูปแบบของ Stateless แล้วนั้นก็ยังมีรูปแบบของ Stateful ที่เราท์เตอร์จะไม่มีความสำคัญใดๆ เลย ซึ่งก็คือการใช้ DHCPv6

2. *Link-Local Unicast Addressing*: จะจอง 10 บิตแรกไว้ ซึ่งก็คือ address ตั้งแต่ `FE80::/10` ไปจนถึง `FEBF::/10` โดยจะใช้เพื่อติดต่อสื่อสารกับอุปกรณ์อื่นภายในเครือข่ายเดียวกันและไม่สามารถถูก route ได้จากโฮสต์ภายนอกเครือข่าย ในเครือข่ายนึงนั้นจะต้องมีอย่างน้อยหนึ่ง Link-Local Address เพื่อถูกใช้จากโฮสต์ภายในเครือข่ายก่อนที่มันจะได้รับ Global Unicast Address เพราะมันจะถูกสร้างโดยอัตโนมัติและจะถูกใช้เป็น Default Gateway ด้วย การที่จะสร้าง Link-Local Address อาจจะทำได้จากการใช้ค่า FE80 บวกกับ 64-bit Interface ID และการได้มาซึ่ง 64-bit Interface ID อาจทำได้ด้วยการใช้ EUI-64 หรือการสุ่มค่าขึ้นมาตามที่กล่าวไว้ในข้างต้นก็ได้ Link-Local Address สามารถถูกสร้างด้วยวิธี Dynamic ได้ แต่จะทำให้ยากต่อการตรวจสอบ (identify) สิ่งที่สำคัญที่สุดก็คือ Link-Local Address จะไม่สามารถซ้ำกันได้ภายในเครือข่ายเลย (unique) โดยจะใช้ Neighbor Discovery Protocol (NDP) ในการตรวจสอบความซ้ำซ้อน

3. *Assigned Multicast*: ทำงานเหมือนใน IPv4 คือเป็นการสื่อสารแบบ one-to-many โดยรูปแบบของ Multicast มากจะเริ่มต้นที่สองบิตแรกเป็นค่าของ FF จากทั้งหมดสี่บิต โดยอีกสองบิตที่เหลือจะเป็น Flag กับ Scope โดยหากค่าของ Flag เป็น 0 จะหมายความว่าเป็น well-known multicast address ซึ่งถูกกำหนดโดย IANA และ 1 จะหมายความว่าเป็นการกำหนด multicast address แบบ dynamic ในส่วนของ Scope มีอยู่ 5 ค่าคือ 0 (Reserved), 1 (Interface-Local Scope), 2 (Link-Local Scope), 5 (Site-Local Scope) และ 8 (Organizational-Local Scope) เช่น FF02 จะบ่งบอกถึงกลุ่มซึ่งชุดของ IPv6 นี้เข้าร่วมอยู่เป็น well-known multicast address อยู่ใน link-local scope

4. *Solicited Node Multicast*: เป็นวิธีการสร้าง Multicast address โดยการเอา 24-bit สุดท้ายของ unicast (และ anycast) address ซึ่งรวมไปถึง Global Unicast Address และ Link-Local Address มาเติมต่อท้าย `FF02:0:0:0:0:1:FF00::/104` ซึ่งมีขนาด 104-bit ซึ่งกรณีที่มีการใช้ EUI-64 สร้าง Interface ID ขึ้นมา แล้วเอา 24-bit สุดท้ายมาทำ Solicited Node Address เหมือนกันจะถือว่ามี Solicited Node Address เพียงอันเดียว

Configuring Sheet:

https://gist.github.com/pe3zx/8258524

Reference:

http://www.cabrillo.edu/~rgraziani/ipv6/Site/IPv6_Videos.html
http://technet.microsoft.com/en-us/library/cc757359(v=ws.10).aspx
http://www.ipv6.nectec.or.th/faq.php
